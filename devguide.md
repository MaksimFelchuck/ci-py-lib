# Правила разработки библиотеки скриптов на Python для ядра cis1

Каждый скрипт - это отдельный файл .py. Он запускается из job-скриптов cis1 как отдельный процесс с помощью ОС. 
Параметры передаются через командную строку.
Код возврата процесса служит индикатором успешности: 0 - успех, Не 0 - ошибка.
Скрипт должен выводить в stdout процесс своего выполнения, в деталях, достаточных для понимания шагов его выполнения и диагностики ошибок.

## Правило обратной совместимости - неприступно

Единожды попав в библиотеку скрипт не имеет право менять свой интерфейс и поведение. 
Для достижения этого существуют такие правила:

- вместе со скриптом заливаются автотесты на него (см. дальше как они устроены и что они делают)
- после заливки этих автотестов они больше никогда не изменяются, а успешность их прохождения проверяется при сборке библиотеки

Таким образом, если какие-либо изменения повлекли ошибку в автотестах, то эти изменения не принимаются к дальнейшему использованию.

При разработке каждого нового скрипта ему присваивается уникальный номер. В имени скрипта этот номер никак не отображается.
Вместе со скриптом в репозитарий заливается каталог с таким именем:

 XXXX_test_<script name>

Где XXXX - тот самый уникальный номер. В каталоге располагаются скрипты тестов, которые именуются следующим образом:

 XXXX_test_N_<script name>.py
 
 Где N - порядковый номер теста.
 
 Тесты, единожды попав в библиотеку, тесты уже не должны изменяться (ну если только по поводу исправления ошибок в них самих), 
 и при "сборке" библиотеки прогоняются все имеющиеся тесты. 
 
 Если хотя-бы один тест не прошел - сборка считается не удачной, и такая версия библиотеки не должна попасть в инсталляционный пакет.
 Скрипт теста при успехе должен завершаться с кодом возврата 0. В случае ошибки код возврата не 0.
 
 Для запуска тестов используется скрипт # Правила разработки библиотеки скриптов на Python для ядра cis1

Каждый скрипт - это отдельный файл .py. Он запускается из job-скриптов cis1 как отдельный процесс с помощью ОС. 
Параметры передаются через командную строку.
Код возврата процесса служит индикатором успешности: 0 - успех, Не 0 - ошибка.
Скрипт должен выводить в stdout процесс своего выполнения, в деталях, достаточных для понимания шагов его выполнения и диагностики ошибок.

## Правило обратной совместимости - неприступно

Единожды попав в библиотеку скрипт не имеет право менять свой интерфейс и поведение. 
Для достижения этого существуют такие правила:

- вместе со скриптом заливаются автотесты на него (см. дальше как они устроены и что они делают)
- после заливки этих автотестов они больше никогда не изменяются, а успешность их прохождения проверяется при сборке библиотеки

Таким образом, если какие-либо изменения повлекли ошибку в автотестах, то эти изменения не принимаются к дальнейшему использованию.

При разработке каждого нового скрипта ему присваивается уникальный номер. В имени скрипта этот номер никак не отображается.
Вместе со скриптом в репозитарий заливается каталог с таким именем:

 XXXX_test_<script name>

Где XXXX - тот самый уникальный номер. В каталоге располагаются скрипты тестов, которые именуются следующим образом:

 XXXX_test_N_<script name>.py
 
 Где N - порядковый номер теста.
 
 Тесты, единожды попав в библиотеку, тесты уже не должны изменяться (ну если только по поводу исправления ошибок в них самих), 
 и при "сборке" библиботеки прогоняются все имеющиеся тесты. 
 
 Если хотя-бы один тест не прошел - сборка считается не удачной, и такая версия библиотеки не должна попасть в инсталляционный пакет.
 
  lib_full_test.py
  
  Он последовательно обходит все каталоги, попадающие под указанную выше маску имени, и последовательно запускает каждый скрипт.
  В случае успеха этот тест возвращет 0, иначе не 0. Он же формирует отчет о прохождении тестов.
  
  При написании тестов обязательно использование следующих правил:
  
  1. В каждом файле должен быть только один тест, если только обратное не продиктовано логикой самого теста
  2. Задача теста - сформировать условия для запуска скрипта и выполнить его вот таким образом:
  
  import lib_test_runner
  res = lib_test_runner.run(['../<script name>', 'arg1',.. ], "Message for report")
 
 3. Завершение скрипта нужно делать таким образом (здесь res - переменная, которая хранит статус возврата предыдущих запусков
 скрипта котрый мы тестируем):
 
 if res:
     lib_test_runner.fail()
 else:
     lib_test_runner.ok()

## Локальная конфигурация

Для работы библиотеки в конкретной инсталляции могут потребоваться локальные настройки. Все эти настройки должны находится в файле 

 lib_config.py
 
который находится вне репозитария. В качестве шаблона для этого файла в репозитарии находится файл

 lib_config.py.sample
 
## Правила работы с репозитарием библиотеки
 
Начало разработки: создается тикет, ему присваевается уникальный номер, описывается интерфейс и поведение нового скрипта, 
скрипту присваивается имя. В репозиратии создается ветка с именем:
 
 ХХХХ_<script name>
  
И вся разработка ведется в ней.
 
Разработка: разработчик скрипта делает его, делает тесты для скрипта, которые должны покрывать все варианты ошибок работы с интерфейсом,
и должны подтвержать работоспособность самого скрипта. Желательно использовать для тестирования скрипта только локальные ресурсы 
(понимаем, что это может быть сложно).
 
Приемка: в ветку разработки должен быть влит самый последний master. Для приемки делается merge request.
Ответственный за библиотеку проверяет код, отвергает или принимает его (на данный момент ответсвтенный Безходарнов И.В.). 
После сливания в master, ветка разработки удаляется.
 
## Правила использования сторонних библиотек

Сторонние библиотеки можно использовать. Лицензия на сторонние библиотеки должна разрешать из бесплатное использование.
Все пункты лицензии сторонней библиотеки должны быть соблюдены. Все сторонние библиотеки должны быть перечислены в файле:

 requirements.txt
 
 Формат файла должен удовлетворять этим требованиям:
 
  https://pip.pypa.io/en/stable/reference/pip_install/#requirements-file-format
  
## Документирование

_TBD_




















